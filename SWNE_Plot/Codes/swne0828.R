library(swne)
library(Seurat)
library(SeuratWrappers)
library(monocle3)
library(ggplot2)

# devtools::install_github("satijalab/seurat", ref = "develop")
path <- "~/data/cwx/swne/";setwd(path)

# use FindMarker in Seurat to find DEG, which will show in the reduction plot
ChooseGene <- function(seu){
  Idents(seu) <- seu$cell_type
  genes <- FindAllMarkers(seu)
  marker <- genes
  genes <- split(genes$gene, genes$cluster)
  genes <- lapply(genes, function(x){x=x[1:15]})
  genes <- as.character(do.call(rbind, genes))
  return(list(marker = marker, genes = genes))
}

# conduct GSEA on the gene loading matrix generated by NMF, to get enriched pathway
FactorInterpret <- function(swne.embedding){
  genesets <- clusterProfiler::read.gmt("msigdb.v7.scRNASeq.symbols.gmt")
  convert <- read.table("mapping table of Mouse gene to human.txt", sep = "\t", header = T)
  genesets <- genesets[genesets$gene%in%convert$HGNC.symbol,]
  genesets <- cbind(genesets, convert[match(genesets$gene, convert$HGNC.symbol),])
  genesets <- genesets[c("term","MGI.symbol")];colnames(genesets) <- c("gs_name","gene_symbol")
  genesets <- split(genesets$gene_symbol, genesets$gs_name)
  weight <- swne.embedding$nmf.res$W
  GSEAres <- lapply(colnames(weight), function(x){
    print(paste0("find pathway for ", x))
    rank <- as.vector(weight[, x])
    names(rank) <- rownames(weight)
    rank <- rank[order(rank,decreasing = T)]
    fgseares <- fgsea::fgseaSimple(pathways = genesets, stats = rank, nperm = 100000, minSize = 15, maxSize = 500, scoreType = "pos")
    fgseares = dplyr::arrange(fgseares, pval, -NES)
  })
  pathway <- lapply(GSEAres, function(x){ x$pathway[1]})
  pathway <- unlist(pathway)
  swne.embedding$H.coords$name <- pathway
  swne.embedding$gsea <- GSEAres
  return(swne.embedding)
}

# Run SWNE, it is advised to assign k manually, because it may report error when finding k automatically(When the found k is less than 3)
NeoRunSWNE <- function(seu, genes.embed, k = NULL, find_pathway = F){
  if (is.null(k)){
    print("k not provided, find k")
    norm.counts <- ExtractNormCounts(seu, obj.type = "seurat", rescale.method = "log")
    k.err <- FindNumFactors(norm.counts[VariableFeatures(seu),], k.range = seq(2,24,2), n.cores = 4, do.plot = T)
    k = as.numeric(names(which(diff(k.err$err)>0)[1]))-2
    print(paste0("k = ", k))
  }
  norm.counts <- ExtractNormCounts(seu, obj.type = "seurat", rescale.method = "log")
  var.genes <- VariableFeatures(seu)
  nmf.res <- RunNMF(norm.counts[var.genes,], k = k)
  seu <- FindNeighbors(seu, k = 10, prune.SNN = 1/15)
  snn <- as(seu@graphs$RNA_snn, "dgCMatrix")
  knn <- as(seu@graphs$RNA_nn, "dgCMatrix") ## Extract kNN matrix
  snn <- PruneSNN(snn, knn, clusters = seu$cell_type, qval.cutoff = 1e-3)
  swne.embedding <- EmbedSWNE(nmf.res$H, SNN = snn, alpha.exp = 1.25, snn.exp = 0.25, n_pull = 3)
  nmf.res$W <- ProjectFeatures(norm.counts, nmf.res$H, n.cores = 4)
  swne.embedding <- EmbedFeatures(swne.embedding, nmf.res$W, genes.embed, n_pull = 3)
  swne.embedding$nmf.res <- nmf.res
  if (find_pathway == T){
    print("finding pathway")
    swne.embedding <- FactorInterpret(swne.embedding)
  }
  return(swne.embedding)
}

# cakculate entropy of a cell
CalculateEntropy <- function(seu, cell){
  vector <- seu@assays$RNA@counts[,cell]
  freq <- vector/sum(vector)
  freq <- freq[freq>0]
  Entropy <- -sum(freq*log(freq,2))
}

# calculate median entropy of partition provided by monocle3
GetEntropy  <- function(seu, cds){
  Entropy <- data.frame(
    row.names = colnames(seu),
    "Entropy" = do.call(rbind, lapply(colnames(seu), function(x){CalculateEntropy(seu, x)})), 
    "Partition" = paste0("Y_", cds@principal_graph_aux$UMAP$pr_graph_cell_proj_closest_vertex)
  )
  MedianEntropy <- split(Entropy$Entropy, Entropy$Partition)
  MedianEntropy <- lapply(MedianEntropy, median)
  MedianEntropy <- do.call(rbind, MedianEntropy)
  Entropy$ME <- MedianEntropy[match(Entropy$Partition, rownames(MedianEntropy))]
  Entropy <- dplyr::arrange(Entropy, -ME)
  return(Entropy)
}

# learn trajectory using monocle3 on reduction generated by SWNE
LearnTrajectoryOnSWNE <- function(seu, swne.embedding){
  cds <- as.cell_data_set(seu)
  cds <- cluster_cells(cds)
  b <- as.matrix(swne.embedding$sample.coords)
  colnames(b) <- c("UMAP_1", "UMAP_2")
  cds@int_colData$reducedDims@listData$UMAP <- b
  cds <- learn_graph(cds, use_partition = F)
  Entropy <- GetEntropy(seu, cds)
  cds <- order_cells(cds, root_pr_nodes = Entropy$Partition[1])
  res <- list(cds, swne.embedding, Entropy)
}


# wrapped function
TrajectoryInferenceOnSWNE <- function(seu, project){
  dfgene <- ChooseGene(seu)
  swne.embedding <- NeoRunSWNE(seu, genes.embed = dfgene$genes, k = 12, find_pathway = T)
  res <- LearnTrajectoryOnSWNE(seu, swne.embedding = swne.embedding)
  return(list(res = res, dfgene = dfgene))
}

# a plot to visualize the distribution of median entropy

# plotdata <- swne.embeding$sample.coords
# plotdata$E <- Entropy$ME
# plotdata$E[plotdata$E<9] = NA
# ggplot(plotdata, aes(x = x, y = y, color = E))+
#   geom_point() +
#   scale_color_continuous(low = "blue",high = "red")

library(BiocParallel)
options(MulticoreParam=MulticoreParam(workers = 20))

# Example
# input is a seurat object
Tumor <- readRDS("Tumor.rds")
Tumor$cell_type <- paste0("Tumor_", Tumor$seurat_clusters)
Tumor <- SplitObject(Tumor, split.by = "Group")
Tumor <- lapply(Tumor, function(x){TrajectoryInferenceOnSWNE(x, "Tumor")})
saveRDS(Tumor, paste0("output/0828/Tumor.rds"))


Fibro <- readRDS("Fibro.rds")
Fibro$cell_type <- paste0("Fibroblast_", Fibro$seurat_clusters)
Fibro <- SplitObject(Fibro, split.by = "Group")
Fibro <- lapply(Fibro, function(x){TrajectoryInferenceOnSWNE(x, "Fibroblast")})
saveRDS(Fibro, paste0("output/0828/Fibro.rds"))

Mye <- readRDS("Mye.rds")
Mye$cell_type <- paste0("Myeloid_", Mye$seurat_clusters)
Mye <- SplitObject(Mye, split.by = "Group")
Mye <- lapply(Mye, function(x){TrajectoryInferenceOnSWNE(x, "Myeloid")})
saveRDS(Mye, paste0("output/0828/Mye.rds"))

# var.genes <- VariableFeatures(seu)
# norm.counts <- ExtractNormCounts(seu, rescale.method = "log")
# nmf.res <- RunNMF(norm.counts[var.genes,], k = 12)
# seu <- FindNeighbors(seu, k = 10, prune.SNN = 1/15)
# snn <- as(seu@graphs$RNA_snn, "dgCMatrix")
# knn <- as(seu@graphs$RNA_nn, "dgCMatrix") ## Extract kNN matrix
# snn <- PruneSNN(snn, knn, clusters = seu$cell_type, qval.cutoff = 1e-3)
# swne.embedding <- EmbedSWNE(nmf.res$H, SNN = snn, alpha.exp = 1.25, snn.exp = 0.25, n_pull = 3)
# nmf.res$W <- ProjectFeatures(norm.counts, nmf.res$H, n.cores = 4)
# swne.embedding <- EmbedFeatures(swne.embedding, nmf.res$W, genes.embed, n_pull = n_pull)
# weight <- nmf.res$W
# 
# rank <- as.vector(weight[,"factor_1"])
# names(rank) <- rownames(weight)
# rank <- rank[order(rank,decreasing = T)]
# genesets <- clusterProfiler::read.gmt("msigdb.v7.4.scRNASeq.symbols.gmt")
# convert <- read.table("mapping table of Mouse gene to human.txt", sep = "\t", header = T)
# genesets <- genesets[genesets$gene%in%convert$HGNC.symbol,]
# genesets <- cbind(genesets, convert[match(genesets$gene, convert$HGNC.symbol),])
# genesets <- genesets[c("term","MGI.symbol")];colnames(genesets) <- c("gs_name","gene_symbol")
# genesets <- split(genesets$gene_symbol, genesets$gs_name)
# # geneset <- msigdbr::msigdbr(species = "Mus musculus", category = "C5")
# # fgsea_set <- split(geneset$gene_symbol, geneset$gs_name)
# fgseares <- fgsea::fgseaSimple(pathways = genesets, stats = rank, nperm = 5000, minSize = 15, maxSize = 500, scoreType = "pos")
# ref <- geneset[,c("gs_name", "gene_symbol")]
# colnames(ref) <- c("ont","gene")
# a<-clusterProfiler::GSEA(geneList = rank, TERM2GENE = geneset)